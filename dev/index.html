<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · StationaryRandomFields.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://EHTJulia.github.io/StationaryRandomFields.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>StationaryRandomFields.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="StationaryRandomFields"><a class="docs-heading-anchor" href="#StationaryRandomFields">StationaryRandomFields</a><a id="StationaryRandomFields-1"></a><a class="docs-heading-anchor-permalink" href="#StationaryRandomFields" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/EHTJulia/StationaryRandomFields.jl">StationaryRandomFields</a>.</p><ul><li><a href="#StationaryRandomFields.AbstractNoiseSignal"><code>StationaryRandomFields.AbstractNoiseSignal</code></a></li><li><a href="#StationaryRandomFields.AbstractPowerSpectrumModel"><code>StationaryRandomFields.AbstractPowerSpectrumModel</code></a></li><li><a href="#StationaryRandomFields.DensityAnalytic"><code>StationaryRandomFields.DensityAnalytic</code></a></li><li><a href="#StationaryRandomFields.IsAnalytic"><code>StationaryRandomFields.IsAnalytic</code></a></li><li><a href="#StationaryRandomFields.ModelModifier"><code>StationaryRandomFields.ModelModifier</code></a></li><li><a href="#StationaryRandomFields.ModifiedPowerSpectrumModel"><code>StationaryRandomFields.ModifiedPowerSpectrumModel</code></a></li><li><a href="#StationaryRandomFields.NoiseSignal"><code>StationaryRandomFields.NoiseSignal</code></a></li><li><a href="#StationaryRandomFields.NotAnalytic"><code>StationaryRandomFields.NotAnalytic</code></a></li><li><a href="#StationaryRandomFields.Renormalize"><code>StationaryRandomFields.Renormalize</code></a></li><li><a href="#StationaryRandomFields.Rotate"><code>StationaryRandomFields.Rotate</code></a></li><li><a href="#StationaryRandomFields.SaturatedPowerLaw"><code>StationaryRandomFields.SaturatedPowerLaw</code></a></li><li><a href="#StationaryRandomFields.SinglePowerLaw"><code>StationaryRandomFields.SinglePowerLaw</code></a></li><li><a href="#StationaryRandomFields.Stretch"><code>StationaryRandomFields.Stretch</code></a></li><li><a href="#StationaryRandomFields.amplitude_map-Tuple{AbstractPowerSpectrumModel, Any}"><code>StationaryRandomFields.amplitude_map</code></a></li><li><a href="#StationaryRandomFields.amplitude_point-Tuple{AbstractPowerSpectrumModel, Vararg{Any}}"><code>StationaryRandomFields.amplitude_point</code></a></li><li><a href="#StationaryRandomFields.basemodel-Tuple{StationaryRandomFields.ModifiedPowerSpectrumModel}"><code>StationaryRandomFields.basemodel</code></a></li><li><a href="#StationaryRandomFields.fourieranalytic-Tuple{AbstractPowerSpectrumModel}"><code>StationaryRandomFields.fourieranalytic</code></a></li><li><a href="#StationaryRandomFields.generate_gaussian_noise-Tuple{AbstractNoiseSignal}"><code>StationaryRandomFields.generate_gaussian_noise</code></a></li><li><a href="#StationaryRandomFields.get_fourier_noise-Tuple{PowerSpectrumNoiseGenerator, AbstractArray}"><code>StationaryRandomFields.get_fourier_noise</code></a></li><li><a href="#StationaryRandomFields.get_power_spectrum-Tuple{PowerSpectrumNoiseGenerator, AbstractArray}"><code>StationaryRandomFields.get_power_spectrum</code></a></li><li><a href="#StationaryRandomFields.modify-Tuple{AbstractPowerSpectrumModel, Vararg{Any}}"><code>StationaryRandomFields.modify</code></a></li><li><a href="#StationaryRandomFields.posangle-Tuple{Rotate}"><code>StationaryRandomFields.posangle</code></a></li><li><a href="#StationaryRandomFields.power_map-Tuple{AbstractPowerSpectrumModel, Tuple}"><code>StationaryRandomFields.power_map</code></a></li><li><a href="#StationaryRandomFields.power_point"><code>StationaryRandomFields.power_point</code></a></li><li><a href="#StationaryRandomFields.renormed-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:AbstractPowerSpectrumModel"><code>StationaryRandomFields.renormed</code></a></li><li><a href="#StationaryRandomFields.rfftsize-Tuple{AbstractNoiseSignal}"><code>StationaryRandomFields.rfftsize</code></a></li><li><a href="#StationaryRandomFields.rotated-Tuple{Any, Any}"><code>StationaryRandomFields.rotated</code></a></li><li><a href="#StationaryRandomFields.scale_fourier"><code>StationaryRandomFields.scale_fourier</code></a></li><li><a href="#StationaryRandomFields.stretched-Tuple{AbstractPowerSpectrumModel, Vararg{Any}}"><code>StationaryRandomFields.stretched</code></a></li><li><a href="#StationaryRandomFields.transform_ν"><code>StationaryRandomFields.transform_ν</code></a></li><li><a href="#StationaryRandomFields.unmodified-Tuple{StationaryRandomFields.ModifiedPowerSpectrumModel}"><code>StationaryRandomFields.unmodified</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.AbstractNoiseSignal" href="#StationaryRandomFields.AbstractNoiseSignal"><code>StationaryRandomFields.AbstractNoiseSignal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractNoiseSignal</code></pre><p>This is an abstract data type for signal data on which powerspectrum noises will be created. The data type contains information to define the dimensions and sizes of data, and provides various methods.</p><p><strong>Mandatory fields</strong></p><ul><li><code>dims::Tuple</code>: dimension of data</li></ul><p><strong>Mandatory methods</strong></p><ul><li><a href="@ref"><code>size</code></a>: returns the size of the signal</li><li><a href="@ref"><code>sizeof</code></a>: returns product of signal dimensions</li><li><a href="@ref"><code>ndims</code></a>: returns the number of the dimension</li><li><a href="#StationaryRandomFields.rfftsize-Tuple{AbstractNoiseSignal}"><code>rfftsize</code></a>: returns the size of the signal in the Fourier plane (for rfft)</li><li><a href="@ref"><code>rfftfreq</code></a>: returns the frequency grid along each dimension in the Fourier plane (for rfft)</li><li><a href="#StationaryRandomFields.generate_gaussian_noise-Tuple{AbstractNoiseSignal}"><code>generate_gaussian_noise</code></a>: returns Gaussian noises in Fourier domain with the size of <code>rfftsize(data)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/noisesignals/abstractnoisesignal.jl#L7-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.AbstractPowerSpectrumModel" href="#StationaryRandomFields.AbstractPowerSpectrumModel"><code>StationaryRandomFields.AbstractPowerSpectrumModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractPowerSpectrumModel{N}</code></pre><p>The abstract model type for a PowerSpectrum at <code>N</code> dimension. To instantiate your own model type you should subtype from this model. Additionally you need to implement the following methods to satify the interface:</p><p><strong>Mandatory Methods</strong></p><ul><li><a href="#StationaryRandomFields.fourieranalytic-Tuple{AbstractPowerSpectrumModel}"><code>fourieranalytic</code></a>: Defines whether the model fourier coefficients  can be computed analytically. If yes  then this should return <code>IsAnalytic()</code> and the user <em>must</em> to define <code>visibility_point</code>.  If not analytic then <code>fourieranalytic</code> should return <code>NotAnalytic()</code>.</li><li><a href="#StationaryRandomFields.power_point"><code>power_point</code></a>: Defines how to compute model power of fourier coefficients pointwise. Note this    must be defined if <code>fourieranalytic(::Type{YourModel})==IsAnalytic()</code>.</li><li><a href="#StationaryRandomFields.power_map-Tuple{AbstractPowerSpectrumModel, Tuple}"><code>power_map</code></a>: Maps the fourier power spectrum for a set of frequencies. </li></ul><p><strong>Optional Methods</strong></p><ul><li><a href="#StationaryRandomFields.amplitude_point-Tuple{AbstractPowerSpectrumModel, Vararg{Any}}"><code>amplitude_point</code></a>: Defines how to compute model amplitudes of fourier coefficients pointwise. Note this   must be defined if <code>fourieranalytic(::Type{YourModel})==IsAnalytic()</code>.   It should be defined as √(power_point(model, ν...)).</li><li><a href="#StationaryRandomFields.amplitude_map-Tuple{AbstractPowerSpectrumModel, Any}"><code>amplitude_map</code></a>: Maps the fourier amplitude spectrum for a grid of frequencies.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/powerspectra/abstractpowerspectrum.jl#L6-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.DensityAnalytic" href="#StationaryRandomFields.DensityAnalytic"><code>StationaryRandomFields.DensityAnalytic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DensityAnalytic</code></pre><p>Internal type for specifying the nature of the model functions. Whether they can be easily evaluated pointwise analytic. This is an internal type that may change.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/powerspectra/abstractpowerspectrum.jl#L32-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.IsAnalytic" href="#StationaryRandomFields.IsAnalytic"><code>StationaryRandomFields.IsAnalytic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct IsAnalytic &lt;: StationaryRandomFields.DensityAnalytic</code></pre><p>Defines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has a analytic fourier transform and/or image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/powerspectra/abstractpowerspectrum.jl#L41-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.ModelModifier" href="#StationaryRandomFields.ModelModifier"><code>StationaryRandomFields.ModelModifier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ModelModifier{T}</code></pre><p>General type for a model modifier. These transform any model using simple Fourier transform properties. To modify a model you can use the <a href="#StationaryRandomFields.ModifiedPowerSpectrumModel"><code>ModifiedPowerSpectrumModel{N}</code></a> constructor or the <a href="#StationaryRandomFields.modify-Tuple{AbstractPowerSpectrumModel, Vararg{Any}}"><code>modify</code></a> function.</p><pre><code class="language-julia-repl hljs">julia&gt; visanalytic(stretched(Disk(), 2.0, 2.0)) == visanalytic(Disk())
true</code></pre><p>To implement a model transform you need to specify the following methods:</p><ul><li><a href="#StationaryRandomFields.transform_ν"><code>transform_ν</code></a></li><li><a href="@ref"><code>transform_image</code></a></li><li><a href="#StationaryRandomFields.scale_fourier"><code>scale_fourier</code></a></li><li><a href="@ref"><code>scale_image</code></a></li><li><a href="@ref"><code>radialextent</code></a></li></ul><p>See the docstrings of those methods for guidance on implementation details.</p><p>Additionally these methods assume the modifiers are of the form</p><p>I(x,y) -&gt; fᵢ(x,y)I(gᵢ(x,y)) V(u,v) -&gt; fᵥ(u,v)V(gᵥ(u,v))</p><p>where <code>g</code> are the transform<em>image/uv functions and <code>f</code> are the scale</em>image/uv function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/powerspectra/modifiers.jl#L3-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.ModifiedPowerSpectrumModel" href="#StationaryRandomFields.ModifiedPowerSpectrumModel"><code>StationaryRandomFields.ModifiedPowerSpectrumModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ModifiedPowerSpectrumModel{N, M&lt;:AbstractPowerSpectrumModel{N}, T&lt;:Tuple} &lt;: AbstractPowerSpectrumModel{N}</code></pre><p>Container type for models that have been transformed in some way. For a list of potential modifiers or transforms see <code>subtypes(ModelModifiers)</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>model</code>: base model</p></li><li><p><code>transform</code>: model transforms</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/powerspectra/modifiers.jl#L53-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.NoiseSignal" href="#StationaryRandomFields.NoiseSignal"><code>StationaryRandomFields.NoiseSignal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NoiseSignal{T&lt;:Tuple} &lt;: AbstractNoiseSignal</code></pre><p>This is a data type for noise signals of any dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/noisesignals/noisesignal.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.NotAnalytic" href="#StationaryRandomFields.NotAnalytic"><code>StationaryRandomFields.NotAnalytic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NotAnalytic &lt;: StationaryRandomFields.DensityAnalytic</code></pre><p>Defines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has does not have a easy analytic fourier transform and/or intensity function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/powerspectra/abstractpowerspectrum.jl#L51-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.Renormalize" href="#StationaryRandomFields.Renormalize"><code>StationaryRandomFields.Renormalize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Renormalize{T} &lt;: StationaryRandomFields.ModelModifier{T}</code></pre><p>Renormalizes the flux of the model to the new value <code>scale*flux(model)</code>. We have also overloaded the Base.:* operator as syntactic sugar although I may get rid of this.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; modify(Gaussian(), Renormalize(2.0)) == 2.0*Gaussian()
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/powerspectra/modifiers.jl#L164-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.Rotate" href="#StationaryRandomFields.Rotate"><code>StationaryRandomFields.Rotate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Rotate(ξ)</code></pre><p>Type for the rotated model. This is more fine grained control of rotated model.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; modify(Gaussian(), Rotate(2.0)) == rotated(Gaussian(), 2.0)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/powerspectra/modifiers.jl#L249-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.SaturatedPowerLaw" href="#StationaryRandomFields.SaturatedPowerLaw"><code>StationaryRandomFields.SaturatedPowerLaw</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">$(TYPEDEF)</code></pre><p>Type for power law with input dimension {N} and profile: <span>$P(\nu) = |\nu| ^{\beta} \end{cases}$</span> when inscale &lt; |ν| &lt; outscale.  When |ν| &gt; outscale: P(ν) = 0.  When |ν| &lt; inscale: <span>$P(\\nu) = (inscale) ^{\\beta} \\end{cases}.$</span></p><p>β refers to the input index. Can be renormalized, stretched, and rotated via ModelModifier.</p><p><strong>Fields</strong></p>FIELDS</div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/powerspectra/saturatedpowerlaw.jl#L2-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.SinglePowerLaw" href="#StationaryRandomFields.SinglePowerLaw"><code>StationaryRandomFields.SinglePowerLaw</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">$(TYPEDEF)</code></pre><p>Type for single power law with input dimension {N} and profile <span>$P(\nu) = |\nu| ^{\beta} \end{cases}$</span> where β is the input index and ν is frequency. Can be renormalized, stretched, and rotated via ModelModifier.</p><p><strong>Fields</strong></p>FIELDS</div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/powerspectra/singlepowerlaw.jl#L2-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.Stretch" href="#StationaryRandomFields.Stretch"><code>StationaryRandomFields.Stretch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Stretch(α, β)
Stretch(r)</code></pre><p>Stretched the model in the x and y directions, i.e. the new intensity is     Iₛ(x,y) = 1/(αβ) I(x/α, y/β), where were renormalize the intensity to preserve the models flux.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; modify(Gaussian(), Stretch(2.0)) == stretched(Gaussian(), 2.0, 1.0)
true</code></pre><p>If only a single argument is given it assumes the same stretch is applied in both direction.</p><pre><code class="language-julia-repl hljs">julia&gt; Stretch(2.0) == Stretch(2.0, 2.0)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/powerspectra/modifiers.jl#L208-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.amplitude_map-Tuple{AbstractPowerSpectrumModel, Any}" href="#StationaryRandomFields.amplitude_map-Tuple{AbstractPowerSpectrumModel, Any}"><code>StationaryRandomFields.amplitude_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">amplitude_map(model::AbstractPowerSpectrumModel, data)</code></pre><p>Function that maps the amplitude function of a signal data frequency grid.  The intended input &quot;data&quot; is the frequency grid output by FFTW.rfftfreq.  Alternatively a SignalNoise or ContinuousSignalNoise object can be input, and the corresponding frequency grid will be computed and mapped.</p><p>In default, it should be defined as .√(power_point(model, data)).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/powerspectra/abstractpowerspectrum.jl#L123-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.amplitude_point-Tuple{AbstractPowerSpectrumModel, Vararg{Any}}" href="#StationaryRandomFields.amplitude_point-Tuple{AbstractPowerSpectrumModel, Vararg{Any}}"><code>StationaryRandomFields.amplitude_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">amplitude_point(model::AbstractPowerSpectrumModel, ν...)</code></pre><p>Function that computes the pointwise amplitude of fourier component at a set of frequencies <code>ν</code>. This must be implemented in the model interface if <code>fourieranalytic(::Type{MyModel}) == IsAnalytic()</code>.</p><p>In default, it should be defined as √(power_point(model, ν...)).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/powerspectra/abstractpowerspectrum.jl#L92-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.basemodel-Tuple{StationaryRandomFields.ModifiedPowerSpectrumModel}" href="#StationaryRandomFields.basemodel-Tuple{StationaryRandomFields.ModifiedPowerSpectrumModel}"><code>StationaryRandomFields.basemodel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basemodel(model::ModifiedPowerSpectrumModel)</code></pre><p>Returns the ModifiedPowerSpectrumModel with the last transformation stripped.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; basemodel(stretched(Disk(), 1.0, 2.0)) == Disk()
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/powerspectra/modifiers.jl#L96-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.fourieranalytic-Tuple{AbstractPowerSpectrumModel}" href="#StationaryRandomFields.fourieranalytic-Tuple{AbstractPowerSpectrumModel}"><code>StationaryRandomFields.fourieranalytic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fourieranalytic(::Type{&lt;:AbstractPowerSpectrumModel})</code></pre><p>Determines whether the model is pointwise analytic in Fourier domain, i.e. we can evaluate its fourier transform at an arbritrary point.</p><p>If <code>IsAnalytic()</code> then it will try to call <code>visibility_point</code> to calculate the complex visibilities. Otherwise it fallback to using the FFT that works for all models that can compute an image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/powerspectra/abstractpowerspectrum.jl#L61-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.generate_gaussian_noise-Tuple{AbstractNoiseSignal}" href="#StationaryRandomFields.generate_gaussian_noise-Tuple{AbstractNoiseSignal}"><code>StationaryRandomFields.generate_gaussian_noise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_gaussian_noise(data::AbstractNoiseSignal; rng=Random.default_rng())</code></pre><p>Generate complex gausisian noises on Fourier space over the frequency space expected for Real FFT. This return a complex array, which is consistent with Fourier-domain representation of a real uncorrelated Gaussian noise with the zero mean and variance of <code>sizeof(data)/2</code> in signal-domain. The size of the output array is given by <code>rfftsize(data)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/noisesignals/abstractnoisesignal.jl#L87-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.get_fourier_noise-Tuple{PowerSpectrumNoiseGenerator, AbstractArray}" href="#StationaryRandomFields.get_fourier_noise-Tuple{PowerSpectrumNoiseGenerator, AbstractArray}"><code>StationaryRandomFields.get_fourier_noise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_fourier_noise(psgen::PowerSpectrumNoiseGenerator, signoise::AbstractArray)</code></pre><p>Retrieve power-spectrum-scaled fourier noise from given signal noise by transforming to fourier space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/noisegenerators/psnoisegenerator.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.get_power_spectrum-Tuple{PowerSpectrumNoiseGenerator, AbstractArray}" href="#StationaryRandomFields.get_power_spectrum-Tuple{PowerSpectrumNoiseGenerator, AbstractArray}"><code>StationaryRandomFields.get_power_spectrum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_power_spectrum(psgen::PowerSpectrumNoiseGenerator, signoise::AbstractArray)</code></pre><p>Retrieve power spectrum from given signal noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/noisegenerators/psnoisegenerator.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.modify-Tuple{AbstractPowerSpectrumModel, Vararg{Any}}" href="#StationaryRandomFields.modify-Tuple{AbstractPowerSpectrumModel, Vararg{Any}}"><code>StationaryRandomFields.modify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modify(m::AbstractPowerSpectrumModel, transforms...)</code></pre><p>Modify a given <code>model</code> using the set of <code>transforms</code>. This is the most general function that allows you to apply a sequence of model transformation for example</p><pre><code class="language-julia-repl hljs">modify(Gaussian(), Stretch(2.0, 1.0), Rotate(π/4), Shift(1.0, 2.0), Renorm(2.0))</code></pre><p>will create a asymmetric Gaussian with position angle <code>π/4</code> shifted to the position (1.0, 2.0) with a flux of 2 Jy. This is similar to Flux&#39;s chain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/powerspectra/modifiers.jl#L129-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.posangle-Tuple{Rotate}" href="#StationaryRandomFields.posangle-Tuple{Rotate}"><code>StationaryRandomFields.posangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">posangle(model)
</code></pre><p>Returns the rotation angle of the rotated <code>model</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/powerspectra/modifiers.jl#L278-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.power_map-Tuple{AbstractPowerSpectrumModel, Tuple}" href="#StationaryRandomFields.power_map-Tuple{AbstractPowerSpectrumModel, Tuple}"><code>StationaryRandomFields.power_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">power_map(model, gridofν)</code></pre><p>Function that maps the power law function of a signal data frequency grid.  The intended input &quot;data&quot; is the frequency grid output by FFTW.rfftfreq.  Alternatively a SignalNoise or ContinuousSignalNoise object can be input,  and the corresponding frequency grid will be computed and mapped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/powerspectra/abstractpowerspectrum.jl#L103-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.power_point" href="#StationaryRandomFields.power_point"><code>StationaryRandomFields.power_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">power_point(model::AbstractPowerSpectrumModel, ν...)</code></pre><p>Function that computes the pointwise amplitude of fourier component at a set of frequencies <code>ν</code>. This must be implemented in the model interface if <code>fourieranalytic(::Type{MyModel}) == IsAnalytic()</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/powerspectra/abstractpowerspectrum.jl#L83-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.renormed-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:AbstractPowerSpectrumModel" href="#StationaryRandomFields.renormed-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:AbstractPowerSpectrumModel"><code>StationaryRandomFields.renormed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">renormed(model, f)
</code></pre><p>Renormalizes the model <code>m</code> to have total flux <code>f*flux(m)</code>. This can also be done directly by calling <code>Base.:*</code> i.e.,</p><pre><code class="language-julia-repl hljs">julia&gt; renormed(m, f) == f*M
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/powerspectra/modifiers.jl#L183-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.rfftsize-Tuple{AbstractNoiseSignal}" href="#StationaryRandomFields.rfftsize-Tuple{AbstractNoiseSignal}"><code>StationaryRandomFields.rfftsize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rfftsize(data::AbstractNoiseSignal)::Tuple</code></pre><p>Returns the size of the Fourier-domain signal</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/noisesignals/abstractnoisesignal.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.rotated-Tuple{Any, Any}" href="#StationaryRandomFields.rotated-Tuple{Any, Any}"><code>StationaryRandomFields.rotated</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotated(model, ξ)
</code></pre><p>Rotates the model by an amount <code>ξ</code> in radians in the clockwise direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/powerspectra/modifiers.jl#L271-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.scale_fourier" href="#StationaryRandomFields.scale_fourier"><code>StationaryRandomFields.scale_fourier</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scale_fourier(model::AbstractModifier, ν...)</code></pre><p>Returns a number on how to scale the fourier coefficients at the frequency coordinate <code>ν</code> for an modified <code>model</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/powerspectra/modifiers.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.stretched-Tuple{AbstractPowerSpectrumModel, Vararg{Any}}" href="#StationaryRandomFields.stretched-Tuple{AbstractPowerSpectrumModel, Vararg{Any}}"><code>StationaryRandomFields.stretched</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stretched(model, α)
</code></pre><p>Stretches the model <code>m</code> according to the formula     Vₛ(u) = V(u1/α1, u2/α2, ...), where were renormalize the intensity to preserve the models flux.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/powerspectra/modifiers.jl#L236-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.transform_ν" href="#StationaryRandomFields.transform_ν"><code>StationaryRandomFields.transform_ν</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform_ν(model::AbstractModifier, ν...)</code></pre><p>Returns a transformed frequency coordinate <code>ν</code> according to the <code>model</code> modifier</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/powerspectra/modifiers.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StationaryRandomFields.unmodified-Tuple{StationaryRandomFields.ModifiedPowerSpectrumModel}" href="#StationaryRandomFields.unmodified-Tuple{StationaryRandomFields.ModifiedPowerSpectrumModel}"><code>StationaryRandomFields.unmodified</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unmodified(model::ModifiedPowerSpectrumModel)</code></pre><p>Returns the un-modified model</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m = stretched(rotated(Gaussian(), π/4), 2.0, 1.0)
julia&gt; umodified(m) == Gaussian()
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/StationaryRandomFields.jl/blob/5f947c4bab1e9ad4bc77735ba3d2191dfa2f73e0/src/powerspectra/modifiers.jl#L81-L92">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 29 June 2023 20:59">Thursday 29 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
