var documenterSearchIndex = {"docs":
[{"location":"math/#Mathematical-Basis","page":"Mathematical Basis","title":"Mathematical Basis","text":"","category":"section"},{"location":"math/","page":"Mathematical Basis","title":"Mathematical Basis","text":"To generate correlated noise, the procedure designated in Timmer et al. (1995) is followed. First, random Gaussian noise G(f) is generated in the Fourier domain, by drawing from a normal distribution at each point in frequency space. The frequency space grid is computed simply from the size of the signal data itself. Fourier Gaussian noise is then scaled by the square root of a designated Fourier domain power function: ","category":"page"},{"location":"math/","page":"Mathematical Basis","title":"Mathematical Basis","text":"$","category":"page"},{"location":"math/","page":"Mathematical Basis","title":"Mathematical Basis","text":"A({f}) = \\sqrt{{P}({f})} = \\sqrt{C |{f}|^{\\beta}} $","category":"page"},{"location":"math/","page":"Mathematical Basis","title":"Mathematical Basis","text":"in which C is a normalization constant and beta is a negative index. This is the most basic power spectrum available for use, but other special power law functions may also be implemented.","category":"page"},{"location":"math/","page":"Mathematical Basis","title":"Mathematical Basis","text":"The power-law-scaled Fourier noise, F(f) = G(f) cdot A(f) is Fourier transformed back into the signal domain to produce the output signal noise:","category":"page"},{"location":"math/","page":"Mathematical Basis","title":"Mathematical Basis","text":"\n    S(x) = frac1N sum_f = 0^NF(f)e^2pi i f x\n\n\nThe above equation is given in one dimension for data of N dimension an N-dimensional backward discrete Fourier transform applies\n\n\n Power Laws\n\nStationaryRandomFieldsjl implements additional power law functions to be substituted as P(f) in the above equations SaturatedPowerLaw takes the standard form of P(f)=f^beta only within the interval f_0 leq f leq f_1  where f_0 and f_1 are input inner and outer scales respectively The spectrum becomes C f_0^beta for all fleq f_0 and 0 for fgeq f_1\n\nPhaseScreenPowerLaw is specific to Interstellar-Medium-generated fluctuations intended for use in Event Horizon Telescope imaging of Sagittarius A* It describes the 2-dimensional phase screen approximation of the ISM following the equation\n\n P(vecf ) = barQ cdot (vecf r_textin)^-(alpha + 2) cdot e^-(vecf r_textin)^2 cdot P_phi(phi)","category":"page"},{"location":"math/","page":"Mathematical Basis","title":"Mathematical Basis","text":"in which phi is the angular polar coordinate of vecf. The constant barQ, inner scale r_in, index alpha, and function P_phi(phi) are taken as input parameters. This type is intended for usage in tandem with the (under-development) package ScatteringOptics.jl.","category":"page"},{"location":"math/","page":"Mathematical Basis","title":"Mathematical Basis","text":"The amplitude-mapping function for PhaseScreenPowerLaw takes an optional parameter for time in hours, t_hr. The function shifts in Fourier space to simulate a phase screen moving according to the screen's velocity by scaling amplitude A(f) with the term: textexp(frac2π iN (s v_x tau + t v_y tau))","category":"page"},{"location":"math/","page":"Mathematical Basis","title":"Mathematical Basis","text":"in which s and t represent the cartesian coordinates of frequency vecf in Fourier space and tau is the given time. v_x and v_y are the x and y components of the phase screen velocity in physical space, optionally defined in the construction of the PhaseScreenPowerLaw object as parameters Vx_km_per_s and Vy_km_per_s.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = StationaryRandomFields","category":"page"},{"location":"#StationaryRandomFields","page":"Home","title":"StationaryRandomFields","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package simulates realistic correlated noise for signal data of any given dimensions. The package follows the power-law noise procedure introduced by Timmer et al. (1995); random Gaussian noise is drawn in the Fourier frequency domain and scaled by the square root of a power law spectrum. An inverse transform back to the signal domain gives the stochastic power-law noise. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The module currently","category":"page"},{"location":"","page":"Home","title":"Home","text":"Provides abstract data types and methods to define noise signals, construct and modify power-law scaling functions, and generate signal noise\nImplements multiple power spectrum types:\nBasic spectra of form P = nu^alpha (SinglePowerLaw)\nCut-off spectra with inner and outer scales (SaturatedPowerLaw)\nISM Phase-Screen power spectra for Event Horizon Telescope use (PhaseScreenPowerLaw)\nProvides methods to reverse the process and retrieve underlying power spectra from input signal noise","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be installed by running:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"StationaryRandomFields\")","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This example code segment uses StationaryRandomFields.jl to generate correlated noise for a signal of given dimensions.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We begin by defining a noise signal object with dimensions input as a tuple. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using StationaryRandomFields\nusing FFTW\n\n# Define a 2D signal with dimensions (1000,1000)\nsignal = NoiseSignal((1000,1000))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can immediately access the RFFT frequency grid that corresponds to the signal dimensions","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ν = rfftfreq(signal)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can also directly create Gaussian noise in Fourier space for the given signal with an optional input of the desired rng (if not the default). This is not a necessary step as the NoiseGenerator will implement it automatically later.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"gnoise = generate_gaussian_noise(signal)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now construct the power spectrum to be used, designating the dimension in brackets. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Create a basic power spectrum with index β = -2\nps = SinglePowerLaw{2}(-2.)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The power spectrum may be modified via renormalization, rotation, and stretching","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"renormed_ps = 1000 * ps \nrotated_ps = rotated(renormed_ps, π/6) # π/6 is the rotation factor\nstretched_ps = stretched(rotated_ps, 100, 100) # 100 is the stretch factor of both axes","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The noise generator requires a ContinuousNoiseSignal as input, which can be created from the original NoiseSignal","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"cns = ContinuousNoiseSignal(signal)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can now create our power spectrum noise generator, composed of the designated power spectrum and continuous noise signal. Note that the power spectrum and noise signal must be of the same dimension. The output signoise gives correlated power-law noise in the signal domain, with dimensions of the original NoiseSignal object.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"noisegen = PSNoiseGenerator(stretched_ps, cns)\n# generate signal noise\nsignoise = generate_signal_noise(noisegen)","category":"page"},{"location":"tutorial/#Plotting","page":"Tutorial","title":"Plotting","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can now plot our generated signal noise in the signal domain:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using CairoMakie\n\n# plot signal noise in position plane\nxgrid = (1:signaltype.dims[1],1:signaltype.dims[2])\nfig = CairoMakie.Figure()\nax = Axis(fig[1,1], title = \"Signal Noise in Image Plane\", xlabel = \"x\", ylabel = \"y\")\ncplot = CairoMakie.contourf!(f[1,1], xgrid..., signoise)\nColorbar(fig[1,2], cplot)\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: fig)","category":"page"}]
}
