var documenterSearchIndex = {"docs":
[{"location":"math/#Mathematical-Basis","page":"Math","title":"Mathematical Basis","text":"","category":"section"},{"location":"math/","page":"Math","title":"Math","text":"To generate correlated noise, the procedure designated in Timmer et al. (1995) is followed. First, random Gaussian noise G(vecf) is generated in the Fourier domain, by drawing from a normal distribution at each point in frequency space. The frequency space grid is computed simply from the size of the signal data itself. Fourier Gaussian noise is then scaled by the square root of a designated Fourier domain power function: ","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"$","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"A(\\vec{f}) = \\sqrt{{P}(\\vec{f})} = \\sqrt{ f^{\\beta}} $","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"in which beta is a negative index and f denotes the vector norm vecf. This is the most basic power spectrum available for use, but other special power law functions may also be implemented.","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"The power-law-scaled Fourier noise, F(vecf) = G(vecf) cdot A(vecf) is inverse Fourier transformed back into the signal domain to produce the output signal noise:","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"$","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"S(\\vec{r}) = \\frac{1}{N} \\sum_{f = 0}^{N}F(\\vec{f})e^{2\\pi i \\vec{f} \\cdot \\vec{r}}","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"$","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"Reversing the process, the approximate power spectrum can be retrieved from a given signal noise S(vecr) via a forward Fourier transform:","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"$","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"\\bar{P}(\\vec{f}) = |F(\\vec{f})|^2 = |\\frac{1}{N} \\sum_{f = 0}^{N}S(\\vec{r})e^{-2\\pi i \\vec{f} \\cdot \\vec{r}}|^2","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"$","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"The approximated power spectrum output by get_power_spectrum divides this above result, barP(vecf), by 2 to correct for a positively skewed offset in the squared amplitude of Gaussian noise.  ","category":"page"},{"location":"math/#Power-Laws","page":"Math","title":"Power Laws","text":"","category":"section"},{"location":"math/","page":"Math","title":"Math","text":"StationaryRandomFields.jl implements additional power law functions to be substituted as P(f) in the above equations. SaturatedPowerLaw takes the standard form of P(vecf)=f^beta only within the interval f_0  f  f_1  where f_0 and f_1 are input inner and outer scale cutoffs (inscale and outscale), respectively. When fleq f_0, the spectrum becomes:","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"$","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"P(\\vec{f})=f_0^{\\beta} $ ","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"and when fgeq f_1: ","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"$","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"P(\\vec{f})=0. $","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = StationaryRandomFields","category":"page"},{"location":"#StationaryRandomFields","page":"Home","title":"StationaryRandomFields","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package simulates realistic correlated noise for signal data of any given dimensions. The package follows the power-law noise procedure introduced by Timmer et al. (1995); random Gaussian noise is drawn in the Fourier frequency domain and scaled by the square root of a power law spectrum. An inverse transform back to the signal domain gives the stochastic power-law noise. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The module currently","category":"page"},{"location":"","page":"Home","title":"Home","text":"Provides abstract data types and methods to define noise signals, construct and modify power-law scaling functions, and generate signal noise\nImplements multiple power spectrum types:\nBasic spectra of form P = nu^alpha (SinglePowerLaw)\nCut-off spectra with inner and outer scales (SaturatedPowerLaw)\nISM Phase-Screen power spectra for Event Horizon Telescope use (PhaseScreenPowerLaw)\nProvides methods to reverse the process and retrieve underlying power spectra from input signal noise","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be installed by running:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"StationaryRandomFields\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"CurrentModule = StationaryRandomFields","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This example code segment uses StationaryRandomFields.jl to generate correlated noise for a signal of given dimensions.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We begin by defining a noise signal object with dimensions input as a tuple. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using StationaryRandomFields\nusing FFTW\n\n# Define a 2D signal with dimensions (1000,1000)\nsignal = NoiseSignal((1000,1000))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can immediately access the RFFT frequency grid that corresponds to the signal dimensions","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ν = rfftfreq(signal)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can also directly create Gaussian noise in Fourier space for the given signal with an optional input of the desired rng (if not the default). This is not a necessary step as the NoiseGenerator will implement it automatically later.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"gnoise = generate_gaussian_noise(signal)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now construct the power spectrum to be used, designating the dimension in brackets. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Create a basic power spectrum with index β = -2\nps = SinglePowerLaw{2}(-2.)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The power spectrum may be modified via renormalization, rotation, and stretching","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"renormed_ps = 1000 * ps \nrotated_ps = rotated(renormed_ps, π/6) # π/6 is the rotation factor\nstretched_ps = stretched(rotated_ps, 100, 100) # 100 is the stretch factor of both axes","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The noise generator requires a ContinuousNoiseSignal as input, which can be created from the original NoiseSignal","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"cns = ContinuousNoiseSignal(signal)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now create a power spectrum noise generator comprising the designated power spectrum and continuous noise signal. Note that the power spectrum and noise signal must be of the same dimension. The output signoise gives correlated power-law noise in the signal domain, with dimensions of the original NoiseSignal object.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"noisegen = PSNoiseGenerator(stretched_ps, cns)\n# generate signal noise\nsignoise = generate_signal_noise(noisegen)","category":"page"},{"location":"tutorial/#Plotting","page":"Tutorial","title":"Plotting","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can now plot our generated signal noise in the signal domain:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using CairoMakie\n\n# plot signal noise in position plane\nxgrid = (1:signal.dims[1],1:signal.dims[2])\nfig = CairoMakie.Figure()\nax = Axis(fig[1,1], title = \"Signal Noise in Image Plane\", xlabel = \"x\", ylabel = \"y\")\ncplot = CairoMakie.contourf!(f[1,1], xgrid..., signoise)\nColorbar(fig[1,2], cplot)\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: fig)","category":"page"}]
}
