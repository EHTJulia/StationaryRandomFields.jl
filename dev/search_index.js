var documenterSearchIndex = {"docs":
[{"location":"math/#Mathematical-Foundations","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"","category":"section"},{"location":"math/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"To generate correlated noise, the procedure designated in Timmer et al. (1995) is followed. First, random Gaussian noise G(f) is generated in the Fourier domain, by drawing from a normal distribution at each point in frequency space. The frequency space grid is computed simply from the size of the signal data itself. Fourier Gaussian noise is then scaled by the square root of a designated Fourier domain power function: ","category":"page"},{"location":"math/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"$","category":"page"},{"location":"math/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"A({f}) = \\sqrt{{P}({f})} = C |{f}|^{_\\beta} $","category":"page"},{"location":"math/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"in which C is a normalization constant and beta is a negative index. This is the most basic power spectrum available for use, but other special power law functions may also be implemented.","category":"page"},{"location":"math/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"The power-law-scaled Fourier noise, F(f) = G(f) cdot A(f) is Fourier transformed back into the signal domain to produce the output signal noise:","category":"page"},{"location":"math/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"$","category":"page"},{"location":"math/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"S(x) = \\frac{1}{N} \\sum_{f = 0}^{N}F(f)e^{2\\pi i f x}.","category":"page"},{"location":"math/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"$","category":"page"},{"location":"math/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"The above equation is given in one dimension; for data of N dimension, an N-dimensional backward discrete Fourier transform applies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = StationaryRandomFields","category":"page"},{"location":"#StationaryRandomFields","page":"Home","title":"StationaryRandomFields","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package simulates realistic correlated noise for signal data of any given dimensions. The package follows the power-law noise procedure introduced by Timmer et al. (1995); random Gaussian noise is drawn in the Fourier frequency domain and scaled by the square root of a power law spectrum. An inverse transform back to the signal domain gives the stochastic power-law noise. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The module currently","category":"page"},{"location":"","page":"Home","title":"Home","text":"Provides abstract data types and methods to define noise signals, construct and modify power-law scaling functions, and generate signal noise\nImplements multiple power spectrum types:\nBasic spectra of form P = nu^alpha\nCut-off spectra with inner and outer scales\nISM Phase-Screen power spectra for Event Horizon Telescope use\nProvides methods to reverse the process and retrieve underlying power spectra from input signal noise","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be installed by running:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"StationaryRandomFields\")","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This example code segment uses StationaryRandomFields.jl to generate correlated noise for a signal of given dimensions.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We begin by defining a noise signal object with dimensions input as a tuple. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using StationaryRandomFields\nusing FFTW\n\n# Define a 2D signal with dimensions (1000,1000)\nsignal = NoiseSignal((1000,1000))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can immediately access the RFFT frequency grid that corresponds to the signal dimensions","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ν = rfftfreq(signal)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can also directly create Gaussian noise in Fourier space for the given signal with an optional input of the desired rng (if not the default). This is not a necessary step as the NoiseGenerator will implement it automatically later.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"gnoise = generate_gaussian_noise(signal)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now construct the power spectrum to be used, designating the dimension in brackets. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Create a basic power spectrum with index β = -2\nps = SinglePowerLaw{2}(-2.)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The power spectrum may be modified via renormalization, rotation, and stretching","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"renormed_ps = 1000 * ps \nrotated_ps = rotated(renormed_ps, π/6) # π/6 is the rotation factor\nstretched_ps = stretched(rotated_ps, 100, 100) # 100 is the stretch factor of both axes","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The noise generator requires a ContinuousNoiseSignal as input, which can be created from the original NoiseSignal","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"cns = ContinuousNoiseSignal(signal)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can now create our power spectrum noise generator, composed of the designated power spectrum and continuous noise signal. Note that the power spectrum and noise signal must be of the same dimension. The output signoise gives correlated power-law noise in the signal domain, with dimensions of the original NoiseSignal object.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"noisegen = PSNoiseGenerator(stretched_ps, cns)\n# generate signal noise\nsignoise = generate_signal_noise(noisegen)","category":"page"},{"location":"tutorial/#Plotting","page":"Tutorial","title":"Plotting","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can now plot our generated signal noise in the signal domain:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using CairoMakie\n\n# plot signal noise in position plane\nxgrid = (1:signaltype.dims[1],1:signaltype.dims[2])\nfig = CairoMakie.Figure()\nax = Axis(fig[1,1], title = \"Signal Noise in Image Plane\", xlabel = \"x\", ylabel = \"y\")\ncplot = CairoMakie.contourf!(f[1,1], xgrid..., signoise)\nColorbar(fig[1,2], cplot)\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: fig)","category":"page"}]
}
